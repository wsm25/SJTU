# 1798. 砍树 PLUS

## 暴力做法
暴力 O(mn) 搜索，可以优化前缀和空间和负数的操作。TLE。

源码在 [`brute-force.cpp`](./brute-force.cpp)

## 单调队列

本题考点为 [单调队列](https://oi-wiki.org/ds/monotonous-queue/)。

单调队列适用于“限定最大长度连续子列的最大/小性质”这类问题。它通过强制入队，pop front 所有失效的元素，
pop end 所有不满足 partial order 的元素，最高效保存了失效和顺序这两个信息。其本质是剪枝+不移动的动态规划。

它有一个要求：单个对象至多产生一个 candidate，因此才能优化到O(n)。

开始我尝试单个单调队列，以“以本元素结尾的最大值”为 dp 变量，则会产生 ~m 个 (sum, lifespan) 组合，还是 O(mn)。

## 双 单调队列

由于区间和=右前缀和-左前缀和，想到维护两个单调队列，一者维护左前缀和的最小值，一者维护右前缀和的最大值。
需要注意的是，在计算区间和时需要左前缀小于右前缀，因此右前缀队列的 pop front 规则是需要比左前缀和队列
的第一项更新。
显然时间复杂度为 O(n)。

## 卡常 TLE

即使用了 O(n) 算法也会遇到卡常（总时间 3000ms）。我尝试使用了位与代替模，效果显著（运行时间降到 2100ms），
但是还是比不上那些比我快了一倍 (1000ms) 的佬们。

源码在 [`double_monoqueue.cpp`](./double_monoqueue.cpp)

## 优化掉右前缀和队列

其实没有必要维护一个右前缀和队列，这等效于每次循环 sum 作为右边界的结果。因为
- 若左右队列 head 都没更新，则没必要更新，且本循环 sum-lefthead 必然比 maxsum 小
- 若左队列 head 变小了，说明本次 sum 创新低，左队列 head 的 index 为当前 index，因此右队列空，没必要更新。
- 若左队列 head 变大了，右队列 head 没变，则本循环的前缀和差必然比之前小，没必要更新
- 若右队列 head 变了，直接拿本循环 sum 与左队列 head 相减，更新 maxsum

综上，可以去除右前缀和队列，直接拿本次循环的 sum 作为有边界即可。

又降到了 1690 ms，但是和佬们还是有不少差距。

源码在 [`main.cpp`](./main.cpp)

## 快读优化
既然一个单调队列只占 400ms 的开销，我合理怀疑佬们有特殊的快读黑魔法。

通过把 input 变成无脑 1，运行时间直接降到了 300ms，印证了我的想法。

通过一个小的 4k buffer，运行时间降到了 1250ms。就这样吧！