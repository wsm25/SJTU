# 1544. 排列还原

看起来好像很数论，很难，实际上如果从后往前看，有个很简单的算法：
- 维护数集
- 从后往前遍历：
  - 如果前面有 n 个更小的，说明本数是第 n+1 小的
  - 取数集中第 n+1 小的，设为本数，从数集里删掉它

核心的问题在于：如何维护一个能删、能查第 n 小值的集合？

## Brute force
采用位压缩的 O(n) 遍历法，单次查询平均复杂度为 O(n/128+32)，常数还算小。

## 搜索树
好好正经一点，本题显然用[搜索树](https://oi.wiki/ds/bst/)。

本题由于元素唯一且性质良好，直接堆数组建（类）搜索树，深度 log(n)，而且只维护
左右 count，不管平衡了（平衡化的开销大概比 log(n) 遍历一次还大）。

我们把 rank、删除两个操作合为一个 `pop_rank`。

内存：输入 `n*sizeof(i32)`，堆数组 `n*2*sizeof(i32)`，最大不超过 `12n`。

内存优化：可以加入 cap 判定，可以少分配一倍 null 节点的内存。