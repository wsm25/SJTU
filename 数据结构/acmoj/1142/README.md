# 1142. 丑数
## 堆做法/Brute Force
直接维护丑数堆，每次取出最小值后，插入该最小值 乘以 所有素数。循环
n 次即得第 n 小的。时间复杂度 O(nklog(n))。

一些考虑
- 去重：对于 *pi 的数，后续只能乘以大于等于 pi 的素数
- 上限估计：为了减少 heap 大小，（顺便防止溢出），需要规定一个上限。
  一个方法是用当 heap.len==n 时的最大值

坑：输入质数没有排序！

放弃性能优化了...开摆！

## 动态规划
这题是典型的变转移参数动态规划，转移方程中的参数是动态维护的。

动态规划矩阵： $dp[i]$ 表示第 $i$ 个丑数。

动态参数： $p[j]$ 表示使得 $dp[n]\times p_j > dp[i-1]$ 的第一个 $n$。

转移方程： $dp[i]=\min_{j\in0..k}\{dp[p[j]]\times p_j\}$

然而，由于时间复杂度是完整的 O(nk)，而不像堆做法中上界的超强剪枝效果，因而常数较小，导致二者在官方测试集中性能基本一致。

小优化： $\min\{dp[p[i]]\times p_j\}$ 实际上可以在维护 $p[i]$ 时顺带维护了。