# 找高频数

对一个包含 N 个int类型数据的无序数组，设计一个函数，从中找到出现频率第 k 高的元素。
当存在多个元素具有相同出现次数时，都视为同一频率排序顺位 ，例如 输入数组为 [1 2 2 3 3 4 4 4 4]，其中 2 和 3 均为 第 2 高频元素，1 为 第 3 高频元素。

要求：

- 不得直接调用sort函数。
- 在 main 函数头部以注释形式给出程序设计思路及时间复杂度说明。

## 输入描述

第 1 行输入数组个数 N (1<=N<=10000) ，N 为正整数.

第 2 行输入 N 个元素，元素为 int 类型的正整数，元素之间以','相隔.

第 3 行输入给定值 k，k 为正整数.
## 输出描述

输出共1行。

- 若存在频率第 k 高的元素，输出该元素。若存在多个相同频率的第 k 高频元素，输出其中值最小的元素 。
- 若不存在，则输出 “error” 。
## 示例
输入举例1
```
9
1,2,2,3,3,4,4,4,4
2
```
输出举例1
```
2
```
输入举例2
```
13
4,2,6,6,3,4,2,2,2,1,6,1,2
3
```
输出举例2
```
1 
```
输入举例3
```
13
4,2,6,6,3,4,2,2,2,1,6,1,2
5
```
输出举例3
```
error
```
## 随想
Treap 应该能做 ( $O(nlog(m))$ ) （其中 $m$ 是不重复元素个数），但是懒得搓了。

有朴素做法：根据计数冒泡。算法复杂度是 $O(nm)$ 如果做个简单
计数跳表或许可以优化一些常数。

由于需要全排序才能 rank，所以算法复杂度不会低于 $O(n+m\log(m))$ 的。我能想到的
最快做法就是用 hash map 进行 $O(1)*n=O(n)$ 计数。